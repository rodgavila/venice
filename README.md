# venice

Our annotation processor generates two interfaces for each element annotated with `@ExampleAnnotation`:

Example:
```
@ExampleAnnotation
class Bar {

}
```

generates

```
interface CanInjectBarKotlin {
   fun inject(obj: Bar)
}
```

and

```
public interface CanInjectBarJava {
  void inject(Bar obj);
}
```

We define two components (one in Java and one in Kotlin) that implement their respective autogenerated interfaces:

```
@Component
interface MyKotlinComponent : CanInjectBarKotlin {
}
```

AND

```
@Component
interface MyJavaComponent extends CanInjectBarJava {
}
```

The component generated by dagger for `MyKotlinComponent` doesn't include the `inject` method:

```
public final class DaggerMyKotlinComponent implements MyKotlinComponent {
  private DaggerMyKotlinComponent() {

  }

  public static Builder builder() {
    return new Builder();
  }

  public static MyKotlinComponent create() {
    return new Builder().build();
  }

  public static final class Builder {
    private Builder() {
    }

    public MyKotlinComponent build() {
      return new DaggerMyKotlinComponent();
    }
  }
}
```

while the Java correctly does:

```
final class DaggerMyJavaComponent implements MyJavaComponent {
  private DaggerMyJavaComponent() {

  }

  public static Builder builder() {
    return new Builder();
  }

  public static MyJavaComponent create() {
    return new Builder().build();
  }

  @Override
  public void inject(Bar obj) { <<<<==== This should also be present in DaggreMyKotlinComponent
  }

  static final class Builder {
    private Builder() {
    }

    public MyJavaComponent build() {
      return new DaggerMyJavaComponent();
    }
  }
}
```

